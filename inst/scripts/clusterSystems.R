# clusterSystems.R
#
# Purpose:
# Version:
# Version history:
# Date:
# Author:
# License:
#
# Input:
# Output:
# Dependencies:
#
# ToDo:
# Notes:
#
# ==============================================================================

# NO SIDE EFFECTS:
# This script can be safely source()'d to define the functions it contains and
# install.packages()/run library() as required.
# All other code will not be executed unless this is done interactively.


# ====  PARAMETERS  ============================================================
#
#      This script uses guard-blocks that prevent execution of
#      code that should not be executed when the entire script
#      is sourced. Thus it can be source()'d to load its functions,
#      or executed interactively.
#

systemDB_name <- "SysDB"


# ====  PACKAGES  ==============================================================
# Load all required packages.
#
# Use non-standard libraries with  package::function() idiom if possible.

if (!require(cluster, quietly=TRUE)) {
  install.packages("cluster")
}
library(cluster)

if (!requireNamespace("BiocManager")) {
  install.packages("BiocManager")
}

if (!require(devtools)) {
  install.packages("devtools")
}
library(devtools)

if (!require(igraph)) {
  install.packages("igraph")
}
library(igraph)


# ====  FUNCTIONS  =============================================================

# Define functions or source external files

# load functions to get data
source("./R/SyDButils.R")
source("./R/fetchData.R")
# load pairwise similarity functions
source("./R/expr_sim.R")
source("./R/tf_sim.R")
source("./R/net_sim.R")
# load function to make similarity matrices
source("./R/make_matrix.R")


# ====  PROCESS  ===============================================================

myDB <- fetchData(systemDB_name)
rootSysIDs <- SyDBgetRootSysIDs(myDB)

sys_names <- names(rootSysIDs)

# initialize a list of the genes in the different systems
systems <- vector(mode="list", length=length(sys_names))
names(systems) <- sys_names

# populate the list with vectors of genes
for (i in seq_along(sys_names)) {
  systems[[i]] <- SyDBgetSysSymbols(myDB, sys_names[i])
}





# make a single vector containing all of the genes from all of the systems together
all_genes <- unique(unlist(systems))

clusterSystems <- function(systems,
                           distances,
                           customDistanceFn,
                           dataSource,
                           clusterMethod,
                           combineMatrices) {

  distanceMatrices <- list()

  for (i in seq_along(distances)) {
    if (distances[i] == "expression_profile") {
      GEO <- fetchData("GEOprofiles")
      expr_sim_matrix <- make_matrix(all_genes, sim_fn =  expr_sim, data_source = GEO)
    }
    if (distances[i] == "transcription_factor") {
      GTRD <- fetchData("GTRDgeneTFs")
      tf_sim_matrix <- make_matrix(all_genes, sim_fn =  tf_sim, data_source = GTRD)
    }
    if ((distances[i] == "network_jaccard") | (distances[i] == "network_distance")) {
      STRING <- fetchData("STRINGedges0.8")
      # convert the STRINGedges object into an igraph object
      STRINGgraph <- graph_from_edgelist(as.matrix(STRINGedges[,1:2]))
      # The string graph does not contain any unconnected vertices, only interactions,
      # so any genes that have no annotated interactions will be missing.
      # Add these missing genes as unconnected nodes in the graph.
      string_genes <- unique(c(STRINGedges$a, STRINGedges$b))
      missing_genes <- setdiff(all_genes, string_genes)
      STRINGgraph <- add.vertices(STRINGgraph, nv = length(missing_genes), name = missing_genes)
      if (distances[i] == "network_jaccard") {
        string_dist_matrix <- make_matrix(all_genes, sim_fn = net_sim, data_source = STRINGgraph)
      } else { # network_distance
        string_matrix <- igraph::distances(STRINGgraph, v = all_genes, to = all_genes)
        # remove all the infinite values generated by unconnected nodes
        # get a number one larger than the largest finite distance in the matrix
        large_num <- max(string_matrix[is.finite(string_matrix)]) + 1
        # replace any infinite distances with this distance
        sel <- is.infinite(string_matrix)
        string_matrix[sel] <- large_num
        # convert to a scale of 0 to 1
        string_matrix <- string_matrix/large_num
        # put it into distance format recognized by clustering functions
        string_dist_matrix <- as.dist(string_matrix)
      }

    }

  }





  # pass the corresponding similarity function for each matrix
   # transcription factor matrix
   # expression matrix

  # convert the similarity matrices to distance (dissimilarity) matrices
  # or just directly make distance matrix for the string data
  tf_dist_matrix <- as.dist(sqrt(1 - tf_sim_matrix))
  expr_dist_matrix <- as.dist(sqrt(1 - expr_sim_matrix))






  # ====== Combine matrices ========

  av_sim <- (tf_sim_matrix + expr_sim_matrix + net_sim_matrix)/3

  max_sim <- pmax(tf_sim_matrix, expr_sim_matrix,  net_sim_matrix)

  max_dist <- as.dist(sqrt(1-max_sim))

  av_dist <- as.dist(sqrt(1-av_sim))

  clust <- hclust(max_dist)
  clust2 <- hclust(av_dist)

  clust3 <- diana(av_dist)

}



# ====  TESTS  =================================================================
if (TRUE) {
  # Enter your function tests here...

}


# [END]
